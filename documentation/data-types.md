# Data Types

Solid.js consists of a few data types. Most aren't needed to be used explicitly in applications but they are key to the underworkings of the library.

## State / Immutable State

This is the most important data type. It has a simple interface.

### constructor(object)

Initializes with object value.

### set(...path, changes)

This merges the changes into the path on the state object. All changes in set operation are applied at the same time so it is often more optimal than replace.

Alternatively if you can do multiple sets in a single call by passing an array of paths and changes.

### replace(...path, value)

This replaces the value at the path on the state object. Sometimes changes need to be made in several locations and this is the easiest way to swap out a specific value. When there is no path it will replace the current state object and notify via diff. This is useful when replacing the state object from the outside like integrating with Time Travel or Redux Dev Tools.

Alternatively if you can do multiple replaces in a single call by passing an array of paths and values.

### select(...(object|fn))

This takes either Observable, Selector, Function or an object that maps keys to an Observable, Selector, or Function. The Object is the most common form but supports the straight fn to be able to map multiple values from a single selector.

### peek(property)

This grabs a wrapped version of the property without triggering the dependency detection of the getter

### on(property, fn)

Manual subscription to the state object. This returns an object with the unsubscribe method.

## Signal

This is a simple Observable with a value property that can be tracked inside a computation. Similar to a BehaviorSubject in RxJS.

### constructor(value)

Initializes with value

### value

Current value of the Signal

### next(value)

Sets the next value of the Signal

### subscribe(observer|next, error, complete)

Standard Observable subscribe method

## Selector

Most common computation. This is a pure computation and inherits from Signal. The supplied function automatically tracks dependencies when it executes.

A selector is smart in that if a Promise or Observable is returned from it's execution it will map the output of that to the selector. This allows Selectors to map both synchronous and asynchronous values. In so unlike many fine grained libraries Asynchronous computations can remain pure.

### constructor(fn, options)

This sets the function that will execute. Currently the only option is 'defer' which is a boolean to indicate whether it should be defered to the microtask queue. Defaults to false.

## Sync

This computation is used to handle side effects and is the non-pure computation. It is not derived from Signal and is not subcribable. It is generally used in the renderer and in libraries that need to keep external data in sync.